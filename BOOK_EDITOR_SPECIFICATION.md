# Humanizer Book Editor Platform Specification

## üéØ Executive Summary

Advanced book editing platform that bridges narrative analysis with professional document production, integrating with the existing Humanizer Lighthouse API for attribute extraction and narrative transformation.

## üèóÔ∏è Architecture Overview

### **Foundation: Zettlr + Custom Extensions**

**Base Platform**: Zettlr (Open Source, Electron-based)
- Native Markdown + LaTeX support
- Extensible plugin architecture  
- Professional export capabilities
- Research workflow integration

**Custom Components**:
- Humanizer Narrative Analysis Plugin
- Attribute Inspector Panel
- Chunk Management System
- CLI Integration Layer

## üìÑ Document Format Specification

### **Enhanced Markdown with Narrative Awareness**

```yaml
---
# Book Metadata
title: "Book Title"
author: "Author Name"
type: "book"
format_version: "1.0"
created: "2025-08-01T12:00:00Z"
modified: "2025-08-01T15:30:00Z"

# Source Analysis
source_analysis:
  total_chunks: 66
  quality_threshold: 0.4
  coherence_score: 0.64
  generation_method: "advanced_semantic_clustering"

# Page Layout Configuration
page:
  size: "letter"           # letter, a4, legal, custom
  orientation: "portrait"  # portrait, landscape
  margins:
    top: "1in"
    bottom: "1in" 
    left: "1.25in"
    right: "1in"

# Headers & Footers
header:
  enabled: true
  height: "0.5in"
  odd_page: "{chapter-title}"
  even_page: "{book-title}"
  font: "Times New Roman"
  size: "10pt"

footer:
  enabled: true
  height: "0.5in"
  center: "Page {page-number}"
  font: "Times New Roman"
  size: "10pt"

# Visual Decorations
decorations:
  chapter_ornaments: true
  section_breaks: "philosophical"  # none, simple, philosophical, academic
  drop_caps: true
  ornamental_borders: false

# Export Settings
export:
  pdf:
    engine: "xelatex"
    bibliography: true
    cross_references: true
  docx:
    template: "academic"
    track_changes: false
  odt:
    libreoffice_compatible: true
---

# {book-title}

:::{.book-metadata}
Generated by Humanizer Lighthouse V2 Book Generation System
Quality Score: {quality-score} | Source Chunks: {chunk-count}
:::

# Chapter 1: {chapter-title}

:::{.chapter-intro}
*This chapter explores {theme-description} through {chunk-count} carefully curated insights.*
:::

## Section 1.1: {section-title}

:::{.narrative-chunk id="chunk_123" source="conversation_225015"}
**Quality Score**: 0.72  
**Source**: Conversation 225015, Message 3  
**Attributes**: persona="contemplative_philosopher", style="reflective", essence_score=0.8

The question of consciousness stands at the heart of human inquiry. When we pause to consider the nature of our own awareness, we encounter a profound mystery that has captivated philosophers, scientists, and contemplatives for millennia.

*[Original context: Handwritten notebook transcript from Journal Recognizer OCR]*
:::

:::{.transformation-note}
*This passage was enhanced using persona="academic_philosopher" while preserving the original contemplative essence.*
:::

:::{.page-decoration type="section-break"}
~~~
:::

## Section 1.2: {section-title}

:::{.narrative-chunk id="chunk_456" source="conversation_225018"}
**Quality Score**: 0.65  
**Source**: Conversation 225018, Message 7  
**Attributes**: persona="curious_inquirer", style="exploratory", essence_score=0.7

When we examine the act of perceiving, we discover that consciousness is not a passive mirror reflecting reality, but an active process of construction and interpretation.
:::

# Chapter 2: {chapter-title}

[Additional chapters follow same structure...]

---

## Appendices

### Appendix A: Source Material Analysis

:::{.source-analysis}
| Chunk ID | Source | Quality | Themes | Transformations |
|----------|--------|---------|--------|----------------|
| chunk_123 | conv_225015 | 0.72 | consciousness, awareness | persona_enhancement |
| chunk_456 | conv_225018 | 0.65 | perception, reality | style_refinement |
:::

### Appendix B: Narrative Attributes Dictionary

:::{.attributes-dictionary}
**Personas Used**:
- contemplative_philosopher: Deep, reflective voice
- curious_inquirer: Questioning, exploratory tone
- academic_scholar: Formal, analytical approach

**Styles Applied**:
- reflective: Thoughtful, introspective
- exploratory: Open-ended, investigative
- analytical: Structured, logical
:::
```

## üõ†Ô∏è Technical Implementation

### **Zettlr Plugin Architecture**

```javascript
// humanizer-book-editor/main.js
const { Plugin } = require('zettlr-plugin-api');

class HumanizerBookEditor extends Plugin {
  constructor() {
    super();
    this.apiBase = 'http://localhost:8100';
    this.currentBook = null;
    this.narrativeChunks = new Map();
  }

  // Plugin lifecycle
  async activate() {
    // Register menu items
    this.addMenuItem('narrative', 'Extract Attributes', this.extractAttributes);
    this.addMenuItem('narrative', 'Transform Chunk', this.transformChunk);
    this.addMenuItem('narrative', 'Analyze Quality', this.analyzeQuality);
    
    // Register custom editor panels
    this.registerPanel('attribute-inspector', AttributeInspectorPanel);
    this.registerPanel('chunk-manager', ChunkManagerPanel);
    
    // Register custom markdown extensions
    this.registerMarkdownExtension('narrative-chunk', NarrativeChunkExtension);
  }

  // Core functionality
  async extractAttributes(selectedText) {
    try {
      const response = await fetch(`${this.apiBase}/api/extract-attributes`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          text: selectedText,
          analysis_depth: 'full',
          include_essence: true
        })
      });
      
      const attributes = await response.json();
      this.displayAttributePanel(attributes);
      return attributes;
    } catch (error) {
      this.showError('Failed to extract attributes', error);
    }
  }

  async transformChunk(chunkId, transformation) {
    const chunk = this.narrativeChunks.get(chunkId);
    if (!chunk) return null;

    try {
      const response = await fetch(`${this.apiBase}/transform`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          text: chunk.content,
          persona: transformation.persona,
          style: transformation.style,
          namespace: transformation.namespace,
          preserve_essence: true
        })
      });
      
      const result = await response.json();
      this.updateChunkContent(chunkId, result.transformed_text);
      return result;
    } catch (error) {
      this.showError('Failed to transform chunk', error);
    }
  }

  async analyzeQuality(text) {
    try {
      const response = await fetch(`${this.apiBase}/api/analyze-quality`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text })
      });
      
      return await response.json();
    } catch (error) {
      this.showError('Failed to analyze quality', error);
    }
  }
}

// Attribute Inspector Panel
class AttributeInspectorPanel {
  constructor(plugin) {
    this.plugin = plugin;
    this.currentChunk = null;
  }

  render() {
    return `
      <div id="attribute-inspector">
        <h3>Chunk Analysis</h3>
        <div id="chunk-info">
          <p><strong>ID:</strong> <span id="chunk-id">-</span></p>
          <p><strong>Quality:</strong> <span id="chunk-quality">-</span></p>
          <p><strong>Source:</strong> <span id="chunk-source">-</span></p>
        </div>
        
        <h4>Attributes</h4>
        <div id="attributes-list">
          <div class="attribute">
            <label>Persona:</label>
            <select id="persona-select">
              <option value="contemplative_philosopher">Contemplative Philosopher</option>
              <option value="curious_inquirer">Curious Inquirer</option>
              <option value="academic_scholar">Academic Scholar</option>
            </select>
          </div>
          <div class="attribute">
            <label>Style:</label>
            <select id="style-select">
              <option value="reflective">Reflective</option>
              <option value="exploratory">Exploratory</option>
              <option value="analytical">Analytical</option>
            </select>
          </div>
        </div>
        
        <div class="actions">
          <button id="apply-transformation">Apply Transformation</button>
          <button id="extract-attributes">Extract Attributes</button>
          <button id="analyze-quality">Analyze Quality</button>
        </div>
      </div>
    `;
  }
}

// Chunk Manager Panel
class ChunkManagerPanel {
  constructor(plugin) {
    this.plugin = plugin;
  }

  render() {
    return `
      <div id="chunk-manager">
        <h3>Narrative Chunks</h3>
        <div id="chunk-tree">
          <!-- Dynamic chunk tree rendered here -->
        </div>
        
        <div class="chunk-actions">
          <button id="import-chunks">Import from Book Generation</button>
          <button id="validate-chunks">Validate All Chunks</button>
          <button id="export-chunk-analysis">Export Analysis</button>
        </div>
      </div>
    `;
  }
}

module.exports = HumanizerBookEditor;
```

### **CLI Integration Layer**

```python
#!/usr/bin/env python3
# scripts/book_editor_cli.py

import argparse
import json
import subprocess
import os
from pathlib import Path
import requests

class BookEditorCLI:
    def __init__(self):
        self.api_base = 'http://localhost:8100'
        self.editor_config = self.load_config()
        
    def load_config(self):
        config_path = Path.home() / '.humanizer' / 'book_editor.json'
        if config_path.exists():
            with open(config_path, 'r') as f:
                return json.load(f)
        return self.default_config()
    
    def default_config(self):
        return {
            'editor': 'zettlr',
            'default_template': 'philosophical',
            'auto_save': True,
            'export_formats': ['pdf', 'docx', 'odt']
        }

    def open_book(self, book_path):
        """Open book in visual editor"""
        if self.editor_config['editor'] == 'zettlr':
            subprocess.run(['zettlr', str(book_path)])
        else:
            subprocess.run([self.editor_config['editor'], str(book_path)])

    def extract_attributes(self, book_path, chunk_id=None):
        """Extract attributes from chunk or selection"""
        book_content = Path(book_path).read_text()
        
        # Parse narrative chunks
        chunks = self.parse_narrative_chunks(book_content)
        
        if chunk_id:
            chunk = chunks.get(chunk_id)
            if not chunk:
                print(f"‚ùå Chunk {chunk_id} not found")
                return
            
            # Extract attributes for specific chunk
            response = requests.post(f'{self.api_base}/api/extract-attributes', 
                json={'text': chunk['content']})
            
            if response.ok:
                attributes = response.json()
                print(f"‚úÖ Attributes extracted for {chunk_id}:")
                print(json.dumps(attributes, indent=2))
            else:
                print(f"‚ùå Failed to extract attributes: {response.text}")
        else:
            # Extract attributes for all chunks
            for chunk_id, chunk in chunks.items():
                print(f"Processing chunk {chunk_id}...")
                # Extract attributes...

    def apply_transformation(self, book_path, chunk_id, persona=None, style=None):
        """Apply narrative transformation to chunk"""
        book_content = Path(book_path).read_text()
        chunks = self.parse_narrative_chunks(book_content)
        
        chunk = chunks.get(chunk_id)
        if not chunk:
            print(f"‚ùå Chunk {chunk_id} not found")
            return
            
        transformation_params = {
            'text': chunk['content'],
            'preserve_essence': True
        }
        
        if persona:
            transformation_params['persona'] = persona
        if style:
            transformation_params['style'] = style
            
        response = requests.post(f'{self.api_base}/transform', 
            json=transformation_params)
        
        if response.ok:
            result = response.json()
            # Update chunk in book
            self.update_chunk_in_book(book_path, chunk_id, result['transformed_text'])
            print(f"‚úÖ Chunk {chunk_id} transformed successfully")
        else:
            print(f"‚ùå Transformation failed: {response.text}")

    def validate_format(self, book_path):
        """Validate document format and structure"""
        book_content = Path(book_path).read_text()
        
        # Validate YAML frontmatter
        if not book_content.startswith('---'):
            print("‚ùå Missing YAML frontmatter")
            return False
            
        # Validate chunk format
        chunks = self.parse_narrative_chunks(book_content)
        print(f"‚úÖ Found {len(chunks)} narrative chunks")
        
        # Validate chunk attributes
        for chunk_id, chunk in chunks.items():
            if not chunk.get('quality_score'):
                print(f"‚ö†Ô∏è  Chunk {chunk_id} missing quality score")
            if not chunk.get('source'):
                print(f"‚ö†Ô∏è  Chunk {chunk_id} missing source information")
                
        return True

    def export_book(self, book_path, format='pdf'):
        """Export book to specified format"""
        book_path = Path(book_path)
        output_path = book_path.with_suffix(f'.{format}')
        
        if format == 'pdf':
            # Use pandoc with custom template
            cmd = [
                'pandoc', str(book_path),
                '-o', str(output_path),
                '--template=humanizer-book-template.tex',
                '--pdf-engine=xelatex',
                '--toc',
                '--number-sections'
            ]
        elif format == 'docx':
            cmd = [
                'pandoc', str(book_path),
                '-o', str(output_path),
                '--reference-doc=humanizer-book-template.docx',
                '--toc'
            ]
        elif format == 'odt':
            cmd = [
                'pandoc', str(book_path),
                '-o', str(output_path),
                '--reference-doc=humanizer-book-template.odt',
                '--toc'
            ]
        
        result = subprocess.run(cmd, capture_output=True, text=True)
        if result.returncode == 0:
            print(f"‚úÖ Book exported successfully: {output_path}")
        else:
            print(f"‚ùå Export failed: {result.stderr}")

    def parse_narrative_chunks(self, content):
        """Parse narrative chunks from markdown content"""
        # Implementation to extract :::{.narrative-chunk} blocks
        chunks = {}
        # ... parsing logic ...
        return chunks

    def update_chunk_in_book(self, book_path, chunk_id, new_content):
        """Update specific chunk content in book file"""
        # Implementation to update chunk content
        pass

def main():
    parser = argparse.ArgumentParser(description='Humanizer Book Editor CLI')
    subparsers = parser.add_subparsers(dest='command', help='Available commands')
    
    # Open command
    open_parser = subparsers.add_parser('open', help='Open book in visual editor')
    open_parser.add_argument('book_path', help='Path to book file')
    
    # Extract attributes command
    extract_parser = subparsers.add_parser('extract-attributes', help='Extract narrative attributes')
    extract_parser.add_argument('book_path', help='Path to book file')
    extract_parser.add_argument('--chunk-id', help='Specific chunk ID to analyze')
    
    # Apply transformation command
    transform_parser = subparsers.add_parser('apply-transformation', help='Apply narrative transformation')
    transform_parser.add_argument('book_path', help='Path to book file')
    transform_parser.add_argument('--chunk-id', required=True, help='Chunk ID to transform')
    transform_parser.add_argument('--persona', help='Persona to apply')
    transform_parser.add_argument('--style', help='Style to apply')
    
    # Validate command
    validate_parser = subparsers.add_parser('validate-format', help='Validate document format')
    validate_parser.add_argument('book_path', help='Path to book file')
    
    # Export command
    export_parser = subparsers.add_parser('export', help='Export book to specified format')
    export_parser.add_argument('book_path', help='Path to book file')
    export_parser.add_argument('--format', choices=['pdf', 'docx', 'odt', 'rtf'], 
                              default='pdf', help='Export format')
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        return
    
    cli = BookEditorCLI()
    
    if args.command == 'open':
        cli.open_book(args.book_path)
    elif args.command == 'extract-attributes':
        cli.extract_attributes(args.book_path, args.chunk_id)
    elif args.command == 'apply-transformation':
        cli.apply_transformation(args.book_path, args.chunk_id, args.persona, args.style)
    elif args.command == 'validate-format':
        cli.validate_format(args.book_path)
    elif args.command == 'export':
        cli.export_book(args.book_path, args.format)

if __name__ == '__main__':
    main()
```

## üöÄ Integration with HAW CLI

```bash
# New HAW commands for book editing
haw book-edit open "conscious_being.md"                    # Open in visual editor
haw book-edit extract-attributes --chunk-id chunk_123     # Extract chunk attributes
haw book-edit apply-transformation --chunk-id chunk_456 --persona "academic" --style "formal"
haw book-edit validate-format "conscious_being.md"        # Validate document structure
haw book-edit export --format pdf "conscious_being.md"    # Export to PDF
haw book-edit chunk-analysis --book "conscious_being.md"  # Analyze all chunks
```

## üìä Export Format Support

### **PDF Export (via LaTeX)**
- Custom LaTeX template with narrative-aware formatting
- Proper chapter/section numbering
- Professional typography
- Embedded metadata and source attribution

### **Microsoft Word (DOCX)**
- Reference document template
- Style mapping for narrative chunks
- Comment integration for attribute notes
- Track changes compatibility

### **OpenDocument (ODT)**
- LibreOffice/OpenOffice compatibility
- Style templates for different content types
- Embedded metadata preservation
- Professional formatting

### **Rich Text Format (RTF)**
- Universal compatibility
- Preserves basic formatting
- Cross-platform support

## üéØ Next Steps

This specification provides a comprehensive foundation for building the advanced book editing platform. The combination of Zettlr as the base editor with custom Humanizer extensions creates a powerful, narrative-aware editing environment that seamlessly integrates with your existing API infrastructure.

Would you like me to:
1. **Begin implementation** of the Zettlr plugin and CLI integration?
2. **Create detailed mockups** of the visual editor interface?
3. **Develop the enhanced document format** with more specific narrative chunk specifications?
4. **Build export templates** for professional document production?