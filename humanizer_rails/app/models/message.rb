# Individual message within a conversation
class Message < ApplicationRecord
  self.primary_key = :id
  
  belongs_to :conversation
  belongs_to :parent_message, class_name: 'Message', optional: true
  has_many :child_messages, class_name: 'Message', foreign_key: 'parent_message_id', dependent: :destroy
  has_many :message_media, dependent: :destroy
  has_many :writebook_sections, foreign_key: :source_message_id, dependent: :nullify
  
  validates :role, presence: true, inclusion: { in: %w[user assistant system tool function] }
  validates :content, presence: true
  validates :message_index, presence: true, uniqueness: { scope: :conversation_id }
  
  scope :by_role, ->(role) { where(role: role) }
  scope :ordered, -> { order(:message_index) }
  scope :with_media, -> { joins(:message_media).distinct }
  scope :search_content, ->(query) { where("content ILIKE ?", "%#{query}%") }
  
  before_validation :generate_id, if: :new_record?
  before_save :calculate_word_count
  after_save :update_conversation_counts
  
  # Convert message to book section
  def to_book_section(writebook, section_options = {})
    section = writebook.writebook_sections.build(
      title: section_options[:title] || generate_section_title,
      content: format_for_book,
      source_conversation_id: conversation_id,
      source_message_id: id,
      section_index: section_options[:index] || (writebook.writebook_sections.maximum(:section_index) || 0) + 1,
      allegory_attributes: section_options[:allegory_attributes] || {}
    )
    
    section
  end
  
  # Apply allegory transformation to this message
  def apply_allegory_transformation(attributes = {})
    allegory_service = AllegoryTransformationService.new(
      namespace: attributes[:namespace] || 'lamish-galaxy',
      persona: attributes[:persona] || 'temnoon',
      style: attributes[:style] || 'contemplative'
    )
    
    transformed_content = allegory_service.transform_content(
      content: content,
      role: role,
      context: message_context
    )
    
    # Create new message with transformed content
    create_transformed_copy(transformed_content, attributes)
  end
  
  def message_context
    {
      conversation_title: conversation.title,
      message_index: message_index,
      role: role,
      has_media: message_media.any?,
      parent_context: parent_message&.content&.first(100)
    }
  end
  
  # Get semantic embedding for this message (future integration)
  def semantic_embedding
    # This would integrate with the embedding system
    # Based on the narrative theory framework
    embedding_service = SemanticEmbeddingService.new
    embedding_service.embed_message(self)
  end
  
  # Check if message contains media
  def has_media?
    message_media.any?
  end
  
  # Get all images associated with this message
  def images
    message_media.where(media_type: 'image')
  end
  
  # Get thread of messages (this message and all ancestors)
  def thread
    messages = [self]
    current = parent_message
    
    while current
      messages.unshift(current)
      current = current.parent_message
    end
    
    messages
  end
  
  # Get conversation branch starting from this message
  def branch
    messages = [self]
    queue = child_messages.to_a
    
    while queue.any?
      current = queue.shift
      messages << current
      queue.concat(current.child_messages.to_a)
    end
    
    messages
  end
  
  # Get Custom GPT information if this message was generated by one
  def custom_gpt
    return nil unless gizmo_id.present?
    @custom_gpt ||= CustomGpt.find_by_gizmo_id(gizmo_id)
  end
  
  # Get display name for the assistant (GPT name or default)
  def assistant_display_name
    if role == 'assistant' && custom_gpt
      custom_gpt.display_name
    elsif role == 'assistant'
      'Assistant'
    else
      role.humanize
    end
  end
  
  # Check if this message was generated by a Custom GPT
  def from_custom_gpt?
    role == 'assistant' && gizmo_id.present? && custom_gpt.present?
  end
  
  # Get gizmo_id from metadata (from Node Archive Browser imports)
  def gizmo_id
    # Check if gizmo_id is stored in metadata (from Node Archive Browser imports)
    metadata&.dig('gizmo_id')
  end
  
  private
  
  def generate_id
    self.id ||= SecureRandom.uuid
  end
  
  def calculate_word_count
    self.word_count = content.to_s.split.length
  end
  
  def update_conversation_counts
    conversation.update_columns(
      message_count: conversation.messages.count,
      word_count: conversation.messages.sum(:word_count)
    ) if conversation
  end
  
  def generate_section_title
    # Generate appropriate title based on content and role
    case role
    when 'user'
      content_preview = content.first(50).gsub(/\s+/, ' ').strip
      "Question: #{content_preview}#{'...' if content.length > 50}"
    when 'assistant'
      "Response #{message_index}"
    when 'system'
      "System Message #{message_index}"
    else
      "Message #{message_index}"
    end
  end
  
  def format_for_book
    formatted_content = content.dup
    
    # Add role prefix for clarity in book format
    role_prefix = case role
    when 'user' then 'üë§ **User**: '
    when 'assistant' then 'ü§ñ **Assistant**: '
    when 'system' then '‚öôÔ∏è **System**: '
    else "**#{role.capitalize}**: "
    end
    
    formatted_content = role_prefix + formatted_content
    
    # Add media references if any
    if has_media?
      media_references = message_media.map do |media|
        case media.media_type
        when 'image'
          "\n\n![#{media.filename}](#{media.file_path})"
        when 'audio'
          "\n\nüéµ Audio: [#{media.filename}](#{media.file_path})"
        when 'video'
          "\n\nüé¨ Video: [#{media.filename}](#{media.file_path})"
        else
          "\n\nüìé Attachment: [#{media.filename}](#{media.file_path})"
        end
      end
      
      formatted_content += media_references.join
    end
    
    # Add timestamp if available
    if original_timestamp
      formatted_content += "\n\n*#{original_timestamp.strftime('%Y-%m-%d %H:%M:%S')}*"
    end
    
    formatted_content
  end
  
  def create_transformed_copy(transformed_content, attributes)
    # Create a new message with transformed content
    # Used for allegory transformations
    new_message = self.class.new(
      conversation: conversation,
      role: role,
      content: transformed_content,
      parent_message_id: parent_message_id,
      message_index: message_index,
      metadata: metadata.merge(
        transformation: attributes,
        original_message_id: id,
        transformed_at: Time.current
      ),
      original_timestamp: original_timestamp
    )
    
    new_message
  end
end